families <- left_join(families, ebvs[,c("FAMILY", "dam_ebv", "sire_ebv", "EBV")], by = "FAMILY")
rm(ebvs)
#parental FAMILY combinations
tmp <- ped
tmp[is.na(tmp$DAM), "DAM"] <- paste0("_dam_",1:sum(is.na(tmp$DAM)))
tmp[is.na(tmp$SIRE), "SIRE"] <- paste0("_sire_",1:sum(is.na(tmp$SIRE)))
tmp$fam <- as.numeric(as.factor(paste0(tmp$DAM, "_", tmp$SIRE)))
tmp <- tmp[,c("ID", "fam")]
tmp$ID <- as.character(tmp$ID)
colnames(tmp) <- c("DAM", "dam_fam")
families  <- left_join(families , tmp[,c("DAM","dam_fam")], by= "DAM")
colnames(tmp) <- c("SIRE", "sire_fam")
families  <- left_join(families , tmp[,c("SIRE","sire_fam")], by= "SIRE")
families <- families[order(as.numeric(families$FAMILY) , decreasing = FALSE), ]
families$fam_combn <- paste0(pmin(families$dam_fam, families$sire_fam, na.rm = T), "_", pmax(families$dam_fam, families$sire_fam, na.rm = T))
families$fam_combn <- as.factor(as.numeric(as.factor(families$fam_combn)))
families$dam_fam   <- as.factor(families$dam_fam)
families$sire_fam  <- as.factor(families$sire_fam)
families <- families[families$F <= max_F,] #remove families with excessive F
tmp1 <- aggregate(!is.na(families[,"DAM"]),by=list(families[,"DAM"]), FUN = "sum")
colnames(tmp1) <- c("ID", "N_possible_families_after_max_F_constraint_applied")
tmp2 <- aggregate(!is.na(families[,"SIRE"]),by=list(families[,"SIRE"]), FUN = "sum")
colnames(tmp2) <- c("ID", "N_possible_families_after_max_F_constraint_applied")
parents <- left_join(parents, rbind(tmp1, tmp2), by = "ID")
rm(tmp1, tmp2)
tmp <- parents$ID[is.na(parents$N_possible_families_after_max_F_constraint_applied)]
if(length(tmp) > 0 ) {
print(parents)
stop(paste("max_F too small given N_AS_PARENT values. Check: ",paste(tmp, sep=" ")))
}
if(sum(parents$N_AS_PARENT > parents$N_possible_families_after_max_F_constraint_applied) > 0) {
print(parents)
stop("max_F too small given N_AS_PARENT values")
}
parents
max_F=1
if("dplyr" %in% installed.packages()[, "Package"] == F) {install.packages("dplyr")}
library(dplyr)
#Data checks
check.H(H)
check.parents(parents)
check.ped(ped)
check.max_F(max_F)
if(sum(!parents$ID %in% rownames(H) > 0)) {
stop("H must contain parents in rownames and colnames")
}
#H matrix with dams in rows and sires in columns
H <- H[rownames(H) %in% parents[parents$SEX == "F","ID"],
colnames(H) %in% parents[parents$SEX == "M","ID"]]
H <- H[!duplicated(rownames(H)),
!duplicated(colnames(H))]
#Loop to create data frame with possible families
families <- NULL
for(row in 1:nrow(H)) {
for(col in 1:ncol(H)) {
families <- rbind(families, cbind(rownames(H)[row], colnames(H)[col], H[row,col]/2))
}
}
colnames(families) <- c("DAM","SIRE", "F")
families   <- as.data.frame(families)
families$F <- as.numeric(families$F)
families$FAMILY <- 1:nrow(families) #Create FAMILY ID
families <- families[c("FAMILY","DAM","SIRE", "F")]
#merge EBV data
ebvs <- left_join(families, parents[,c("ID", "EBV")], by = c("DAM"  = "ID"))
ebvs <- left_join(ebvs, parents[,c("ID", "EBV")], by = c("SIRE" = "ID"))
ebvs$EBV <- rowMeans(ebvs[,c("EBV.x","EBV.y")], na.rm = T)
ebvs[is.na(ebvs$EBV.x),"EBV"] <- NA
ebvs[is.na(ebvs$EBV.y),"EBV"] <- NA
colnames(ebvs)[colnames(ebvs) == "EBV.x"] <- "dam_ebv"
colnames(ebvs)[colnames(ebvs) == "EBV.y"] <- "sire_ebv"
families <- left_join(families, ebvs[,c("FAMILY", "dam_ebv", "sire_ebv", "EBV")], by = "FAMILY")
rm(ebvs)
#parental FAMILY combinations
tmp <- ped
tmp[is.na(tmp$DAM), "DAM"] <- paste0("_dam_",1:sum(is.na(tmp$DAM)))
tmp[is.na(tmp$SIRE), "SIRE"] <- paste0("_sire_",1:sum(is.na(tmp$SIRE)))
tmp$fam <- as.numeric(as.factor(paste0(tmp$DAM, "_", tmp$SIRE)))
tmp <- tmp[,c("ID", "fam")]
tmp$ID <- as.character(tmp$ID)
colnames(tmp) <- c("DAM", "dam_fam")
families  <- left_join(families , tmp[,c("DAM","dam_fam")], by= "DAM")
colnames(tmp) <- c("SIRE", "sire_fam")
families  <- left_join(families , tmp[,c("SIRE","sire_fam")], by= "SIRE")
families <- families[order(as.numeric(families$FAMILY) , decreasing = FALSE), ]
families$fam_combn <- paste0(pmin(families$dam_fam, families$sire_fam, na.rm = T), "_", pmax(families$dam_fam, families$sire_fam, na.rm = T))
families$fam_combn <- as.factor(as.numeric(as.factor(families$fam_combn)))
families$dam_fam   <- as.factor(families$dam_fam)
families$sire_fam  <- as.factor(families$sire_fam)
families <- families[families$F <= max_F,] #remove families with excessive F
tmp1 <- aggregate(!is.na(families[,"DAM"]),by=list(families[,"DAM"]), FUN = "sum")
colnames(tmp1) <- c("ID", "N_possible_families_after_max_F_constraint_applied")
tmp2 <- aggregate(!is.na(families[,"SIRE"]),by=list(families[,"SIRE"]), FUN = "sum")
colnames(tmp2) <- c("ID", "N_possible_families_after_max_F_constraint_applied")
parents <- left_join(parents, rbind(tmp1, tmp2), by = "ID")
rm(tmp1, tmp2)
tmp <- parents$ID[is.na(parents$N_possible_families_after_max_F_constraint_applied)]
if(length(tmp) > 0 ) {
print(parents)
stop(paste("max_F too small given N_AS_PARENT values. Check: ",paste(tmp, sep=" ")))
}
if(sum(parents$N_AS_PARENT > parents$N_possible_families_after_max_F_constraint_applied) > 0) {
print(parents)
stop("max_F too small given N_AS_PARENT values")
}
data(ped)
data(parents)
#mhamilton@cgiar.org
#Feb 2021
if("nadiv" %in% installed.packages()[, "Package"] == F) {install.packages("nadiv")}
library(nadiv)
check.ped(ped)
check.parents(parents)
check.n_fam_crosses(n_fam_crosses)
check.max_F(max_F)
check.method(method)
ped <- reduce.ped(ped = ped, parents = parents)
ped[ped$DAM  == 0 & !is.na(ped$DAM), "DAM"]  <- NA
ped[ped$SIRE == 0 & !is.na(ped$SIRE),"SIRE"] <- NA
ped <- prepPed(ped)
H <- makeA(ped)
H <- H[rownames(H) %in% parents$ID, colnames(H) %in% parents$ID]
H <- as.matrix(H)
if("dplyr" %in% installed.packages()[, "Package"] == F) {install.packages("dplyr")}
library(dplyr)
#Data checks
check.H(H)
check.parents(parents)
check.ped(ped)
check.max_F(max_F)
if(sum(!parents$ID %in% rownames(H) > 0)) {
stop("H must contain parents in rownames and colnames")
}
#H matrix with dams in rows and sires in columns
H <- H[rownames(H) %in% parents[parents$SEX == "F","ID"],
colnames(H) %in% parents[parents$SEX == "M","ID"]]
H <- H[!duplicated(rownames(H)),
!duplicated(colnames(H))]
#Loop to create data frame with possible families
families <- NULL
for(row in 1:nrow(H)) {
for(col in 1:ncol(H)) {
families <- rbind(families, cbind(rownames(H)[row], colnames(H)[col], H[row,col]/2))
}
}
colnames(families) <- c("DAM","SIRE", "F")
families   <- as.data.frame(families)
families$F <- as.numeric(families$F)
families$FAMILY <- 1:nrow(families) #Create FAMILY ID
families <- families[c("FAMILY","DAM","SIRE", "F")]
#merge EBV data
ebvs <- left_join(families, parents[,c("ID", "EBV")], by = c("DAM"  = "ID"))
ebvs <- left_join(ebvs, parents[,c("ID", "EBV")], by = c("SIRE" = "ID"))
ebvs$EBV <- rowMeans(ebvs[,c("EBV.x","EBV.y")], na.rm = T)
ebvs[is.na(ebvs$EBV.x),"EBV"] <- NA
ebvs[is.na(ebvs$EBV.y),"EBV"] <- NA
colnames(ebvs)[colnames(ebvs) == "EBV.x"] <- "dam_ebv"
colnames(ebvs)[colnames(ebvs) == "EBV.y"] <- "sire_ebv"
families <- left_join(families, ebvs[,c("FAMILY", "dam_ebv", "sire_ebv", "EBV")], by = "FAMILY")
rm(ebvs)
#parental FAMILY combinations
tmp <- ped
tmp[is.na(tmp$DAM), "DAM"] <- paste0("_dam_",1:sum(is.na(tmp$DAM)))
tmp[is.na(tmp$SIRE), "SIRE"] <- paste0("_sire_",1:sum(is.na(tmp$SIRE)))
tmp$fam <- as.numeric(as.factor(paste0(tmp$DAM, "_", tmp$SIRE)))
tmp <- tmp[,c("ID", "fam")]
tmp$ID <- as.character(tmp$ID)
colnames(tmp) <- c("DAM", "dam_fam")
families  <- left_join(families , tmp[,c("DAM","dam_fam")], by= "DAM")
colnames(tmp) <- c("SIRE", "sire_fam")
families  <- left_join(families , tmp[,c("SIRE","sire_fam")], by= "SIRE")
families <- families[order(as.numeric(families$FAMILY) , decreasing = FALSE), ]
families$fam_combn <- paste0(pmin(families$dam_fam, families$sire_fam, na.rm = T), "_", pmax(families$dam_fam, families$sire_fam, na.rm = T))
families$fam_combn <- as.factor(as.numeric(as.factor(families$fam_combn)))
families$dam_fam   <- as.factor(families$dam_fam)
families$sire_fam  <- as.factor(families$sire_fam)
families <- families[families$F <= max_F,] #remove families with excessive F
tmp1 <- aggregate(!is.na(families[,"DAM"]),by=list(families[,"DAM"]), FUN = "sum")
colnames(tmp1) <- c("ID", "N_possible_families_after_max_F_constraint_applied")
tmp2 <- aggregate(!is.na(families[,"SIRE"]),by=list(families[,"SIRE"]), FUN = "sum")
colnames(tmp2) <- c("ID", "N_possible_families_after_max_F_constraint_applied")
parents <- left_join(parents, rbind(tmp1, tmp2), by = "ID")
rm(tmp1, tmp2)
tmp <- parents$ID[is.na(parents$N_possible_families_after_max_F_constraint_applied)]
if(length(tmp) > 0 ) {
print(parents)
stop(paste("max_F too small given N_AS_PARENT values. Check: ",paste(tmp, sep=" ")))
}
if(sum(parents$N_AS_PARENT > parents$N_possible_families_after_max_F_constraint_applied) > 0) {
print(parents)
stop("max_F too small given N_AS_PARENT values")
}
parents
str(families)
source('C:/Users/mhamilton/Desktop/AllocateMate/R/allocate.mate.ped.R')
source('C:/Users/mhamilton/Desktop/AllocateMate/R/peripheral_functions.R')
data(ped)
data(parents)
output <- allocate.mate.ped(ped, parents, max_F = 0.08, method = "min_F", n_fam_crosses = 1)
output$summary
head(output$all_families)
head(output$optimal_families)
data(ped)
data(parents)
output <- allocate.mate.ped(ped, parents, max_F = 0.08, method = "assortative", n_fam_crosses = 1)
output$summary
head(output$all_families)
head(output$optimal_families)
data(ped)
data(parents)
#mhamilton@cgiar.org
#Feb 2021
if("nadiv" %in% installed.packages()[, "Package"] == F) {install.packages("nadiv")}
library(nadiv)
check.ped(ped)
check.parents(parents)
check.n_fam_crosses(n_fam_crosses)
check.max_F(max_F)
check.method(method)
ped <- reduce.ped(ped = ped, parents = parents)
ped[ped$DAM  == 0 & !is.na(ped$DAM), "DAM"]  <- NA
ped[ped$SIRE == 0 & !is.na(ped$SIRE),"SIRE"] <- NA
ped <- prepPed(ped)
H <- makeA(ped)
H <- H[rownames(H) %in% parents$ID, colnames(H) %in% parents$ID]
H <- as.matrix(H)
families <- generate.fams(H = H, ped = ped, parents = parents, max_F = max_F)
max_F
max_F= 0.08
data(ped)
data(parents)
#mhamilton@cgiar.org
#Feb 2021
if("nadiv" %in% installed.packages()[, "Package"] == F) {install.packages("nadiv")}
library(nadiv)
check.ped(ped)
check.parents(parents)
check.n_fam_crosses(n_fam_crosses)
check.max_F(max_F)
check.method(method)
ped <- reduce.ped(ped = ped, parents = parents)
ped[ped$DAM  == 0 & !is.na(ped$DAM), "DAM"]  <- NA
ped[ped$SIRE == 0 & !is.na(ped$SIRE),"SIRE"] <- NA
ped <- prepPed(ped)
H <- makeA(ped)
H <- H[rownames(H) %in% parents$ID, colnames(H) %in% parents$ID]
H <- as.matrix(H)
families <- generate.fams(H = H, ped = ped, parents = parents, max_F = max_F)
str(families)
parents
families
families[families$F <= max_F,"fam_combn"]
families$F
max_F
families$F <= max_F
families[families$F > max_F,"fam_combn"]
families[families$F > max_F,"fam_combn"] <- 0
families$fam_combn <- paste0(pmin(families$dam_fam, families$sire_fam, na.rm = T), "_", pmax(families$dam_fam, families$sire_fam, na.rm = T))
families$fam_combn <- as.numeric(as.factor(families$fam_combn))
families[families$F > max_F,"fam_combn"] <- 0
families$fam_combn <- as.factor(families$fam_combn)
families$fam_combn <- paste0(pmin(families$dam_fam, families$sire_fam, na.rm = T), "_", pmax(families$dam_fam, families$sire_fam, na.rm = T))
families$fam_combn <- as.factor(as.numeric(as.factor(families$fam_combn)))
families$dam_fam   <- as.factor(families$dam_fam)
families$sire_fam  <- as.factor(families$sire_fam)
families[families$F > max_F,"fam_combn"] <- NA
source('C:/Users/mhamilton/Desktop/AllocateMate/R/peripheral_functions.R')
data(ped)
data(parents)
#Feb 2021
if("nadiv" %in% installed.packages()[, "Package"] == F) {install.packages("nadiv")}
library(nadiv)
check.ped(ped)
check.parents(parents)
check.n_fam_crosses(n_fam_crosses)
check.max_F(max_F)
check.method(method)
ped <- reduce.ped(ped = ped, parents = parents)
ped[ped$DAM  == 0 & !is.na(ped$DAM), "DAM"]  <- NA
ped[ped$SIRE == 0 & !is.na(ped$SIRE),"SIRE"] <- NA
ped <- prepPed(ped)
H <- makeA(ped)
H <- H[rownames(H) %in% parents$ID, colnames(H) %in% parents$ID]
H <- as.matrix(H)
families <- generate.fams(H = H, ped = ped, parents = parents, max_F = max_F)
families
min_trait = "EBV_dev_squared"
if("lpSolveAPI" %in% installed.packages()[, "Package"] == F) {install.packages("lpSolveAPI")}
library(lpSolveAPI)
if("dplyr" %in% installed.packages()[, "Package"] == F) {install.packages("dplyr")}
library(dplyr)
#Data checks
check.parents(parents)
check.n_fam_crosses(n_fam_crosses)
fam_combns   <- as.matrix(levels(families$fam_combn))
N_fam_combns <- length(fam_combns)
EBV_mean <- sum(parents$EBV * parents$N_AS_PARENT) / sum(parents$N_AS_PARENT)
families$EBV_dev_squared <- -abs(families$EBV - EBV_mean)^2
#Linear Programming to minimise F#########################################
#http://www.icesi.edu.co/CRAN/web/packages/lpSolveAPI/vignettes/lpSolveAPI.pdf
print("Creating lpSolve linear program model object")
mate_lp <- make.lp(nrow(parents)+N_fam_combns, nrow(families))
#creates an lpSolve linear program model object with nrow(parents) + levels of fam_combn constraints and nrow(families) decision variables
for(fam in 1:nrow(families)) {
par_count_temp <- NULL
#Count times par is a parent in fam.  Will equal 0 (neither SIRE nor DAM), 1 (SIRE or DAM) or 2 (if self)
for(par in 1:nrow(parents)){
par_count <- as.matrix((families[fam,"DAM"] == parents[par,1]) + (families[fam,"SIRE"] == parents[par,1]))
par_count_temp <- as.matrix(cbind(par_count_temp,par_count))
}
par_count_temp <- as.vector(par_count_temp)
par_fam_count_temp <- as.vector(1*(fam_combns == as.numeric(families[fam,"fam_combn"])))
#vector of counts for the number of times par is a parent in fam
set.column(mate_lp, fam, c(par_count_temp,par_fam_count_temp))
#Constrain FAMILY count to 0 or 1 (i.e. binary)
set.type(mate_lp, fam, "binary")
}
set.objfn(mate_lp, as.numeric(families[,min_trait]))
set.constr.type(mate_lp, c(rep("=",nrow(parents)),rep("<=",N_fam_combns)))
rep(n_fam_crosses,length(fam_combns))
set.constr.type
c(parents[,"N_AS_PARENT"],rep(n_fam_crosses,length(fam_combns)))
fam_combns
as.matrix(levels(families$fam_combn))
families$fam_combn
levels
families[order(levels(families$fam_combn)),]$fam_combn
families[order((families$fam_combn)),]$fam_combn
levels(families$fam_combn)
levels(families[,"fam_combn"])
levels(families[10:20,"fam_combn"])
(families[10:20,"fam_combn"])
fam_combns
families
families
head(families)
families[families$F > max_F,"fam_combn"]
fam_combns
rep(n_fam_crosses,length(fam_combns))
list(c(parents[,"ID"],(-1*as.numeric(fam_combns))),families[,"FAMILY"])
fam_combns %in% families[families$F > max_F,"fam_combn"]
tmp[fam_combns %in% families[families$F > max_F,"fam_combn"]]
tmp <- rep(n_fam_crosses,length(fam_combns))
tmp[fam_combns %in% families[families$F > max_F,"fam_combn"]]
source('C:/Users/mhamilton/Desktop/AllocateMate/R/peripheral_functions.R')
library(AllocateMate)
#Retrieve example data
data(ped)
data(parents)
output <- allocate.mate.ped(ped, parents, max_F = 0.08, method = "min_F", n_fam_crosses = 1)
output$summary
head(output$all_families)
head(output$optimal_families)
source('C:/Users/mhamilton/Desktop/AllocateMate/R/peripheral_functions.R')
library(AllocateMate)
library(AllocateMate)
#Retrieve example data
data(ped)
data(parents)
output <- allocate.mate.ped(ped, parents, max_F = 0.08, method = "min_F", n_fam_crosses = 1)
output$summary
head(output$all_families)
head(output$optimal_families)
#Retrieve example data
data(ped)
data(parents)
output <- allocate.mate.ped(ped, parents, max_F = 1, method = "min_F", n_fam_crosses = 1)
output$summary
head(output$all_families)
head(output$optimal_families)
#Retrieve example data
data(ped)
data(parents)
output <- allocate.mate.ped(ped, parents, max_F = 0., method = "min_F", n_fam_crosses = 1)
output$summary
head(output$all_families)
head(output$optimal_families)
#Retrieve example data
data(ped)
data(parents)
output <- allocate.mate.ped(ped, parents, max_F = 0.015, method = "min_F", n_fam_crosses = 1)
output$summary
head(output$all_families)
head(output$optimal_families)
#Retrieve example data
data(ped)
data(parents)
output <- allocate.mate.ped(ped, parents, max_F = 1, method = "min_F", n_fam_crosses = 1)
output$summary
head(output$all_families)
head(output$optimal_families)
#Retrieve example data
data(ped)
data(parents)
output <- allocate.mate.ped(ped, parents, max_F = 0.0156, method = "min_F", n_fam_crosses = 1)
output$summary
head(output$all_families)
head(output$optimal_families)
#Retrieve example data
data(ped)
data(parents)
output <- allocate.mate.ped(ped, parents, max_F = 0.0157, method = "min_F", n_fam_crosses = 1)
output$summary
head(output$all_families)
head(output$optimal_families)
data(ped)
data(parents)
library(AllocateMate)
data(ped)
data(parents)
#Retrieve example data
data(ped)
data(parents)
output <- allocate.mate.ped(ped, parents, max_F = 0.08, method = "min_F", n_fam_crosses = 1)
output$summary
head(output$all_families)
head(output$optimal_families)
#Retrieve example data
data(ped)
data(parents)
output <- allocate.mate.H(ped, parents, max_F = 0.08, method = "min_F", n_fam_crosses = 1)
output$summary
head(output$all_families)
head(output$optimal_families)
#Retrieve example data
data(ped)
data(parents)
output <- allocate.mate.H(ped, parents, max_F = 0.08, method = "min_F")
output$summary
head(output$all_families)
head(output$optimal_families)
#Retrieve example data
data(H)
data(parents)
output <- allocate.mate.H(H, parents, max_F = 0.08, method = "min_F")
output$summary
head(output$all_families)
head(output$optimal_families)
data(H)
data(parents)
#Feb 2021
if("nadiv" %in% installed.packages()[, "Package"] == F) {install.packages("nadiv")}
library(nadiv)
check.ped(ped)
check.parents(parents)
check.n_fam_crosses(n_fam_crosses)
check.max_F(max_F)
check.method(method)
ped <- reduce.ped(ped = ped, parents = parents)
ped[ped$DAM  == 0 & !is.na(ped$DAM), "DAM"]  <- NA
ped[ped$SIRE == 0 & !is.na(ped$SIRE),"SIRE"] <- NA
ped <- prepPed(ped)
H <- makeA(ped)
H <- H[rownames(H) %in% parents$ID, colnames(H) %in% parents$ID]
H <- as.matrix(H)
families <- generate.fams(H = H, ped = ped, parents = parents, max_F = max_F)
output <- solve_lp(families = families, parents = parents, n_fam_crosses = n_fam_crosses, max_F = max_F, min_trait = "EBV_dev_squared")
output
#Retrieve example data
data(H)
data(parents)
output <- allocate.mate.H(H, parents, max_F = 0.08, method = "min_F")
output$summary
head(output$all_families)
head(output$optimal_families)
#Retrieve example data
data(H)
data(parents)
output <- allocate.mate.H(H, parents, max_F = 0.08, method = "assortative")
output$summary
head(output$all_families)
head(output$optimal_families)
data(H)
data(parents)
output <- allocate.mate.H(H, parents, max_F = 0., method = "min_F")
parents$ID[parents$N_AS_PARENT > parents$N_possible_families_after_max_F_constraint_applied]
tmp <- parents$ID[parents$N_AS_PARENT > parents$N_possible_families_after_max_F_constraint_applied]
length(tmp) > 0
parents[is.na(parents$N_possible_families_after_max_F_constraint_applied),]
output <- allocate.mate.H(H, parents, max_F = 0., method = "min_F") stop ("Linear program not solved.  Try relaxing max_F constraint or altering /'N_AS_PARENT/' values to maximise the number of possible mating pairs with coefficients of coancestry below max_F.")
stop ("Linear program not solved.  Try relaxing max_F constraint or altering /'N_AS_PARENT/' values to maximise the number of possible mating pairs with coefficients of coancestry below max_F.")
print ("Linear program not solved.  Try relaxing max_F constraint or altering /'N_AS_PARENT/' values to maximise the number of possible mating pairs with coefficients of coancestry below max_F.")
print ("Linear program not solved.  Try relaxing max_F constraint or altering \'N_AS_PARENT\' values to maximise the number of possible mating pairs with coefficients of coancestry below max_F.")
library(AllocateMate)
usethis::use_citation()
paste0(“Jose Pinheiro, Douglas Bates, Saikat DebRoy,”,                 “Deepayan Sarkar and the R Core Team (“,                 year,                 “). nlme: Linear and Nonlinear Mixed Effects Models. “,                 note, “.”)
library(AllocateMate)
citation("AllocateMate")
library(AllocateMate)
citation("AllocateMate")
help("citation")
library(AllocateMate)
citation("AllocateMate")
library(AllocateMate)
citation("AllocateMate")
library(AllocateMate)
citation("AllocateMate")
library(AllocateMate)
library(AllocateMate)
library(AllocateMate)
citation("AllocateMate")
library(AllocateMate)
citation("AllocateMate")
data(H)
data(parents)
output <- allocate.mate.H(H, parents, max_F = 0.08, method = "min_F")
output$summary
head(output$all_families)
head(output$optimal_families)
library(AllocateMate)
library(AllocateMate)
library(AllocateMate)
